---
title: Engineering A Compiler(Cooper and Torczon) Notes
---
<h1 id="overview-of-compilation">Overview of Compilation</h1>
<h2 id="introduction">Introduction</h2>
<p>A <strong>compiler</strong> is a computer program that translates other computer programs into a program in another language. The <strong>front-end</strong> deals with the original language and the <strong>back-end</strong> deals with the target language. To connect the front-end and back-end we have some intermediate representation that is language-agnostic. Compilers sometimes also optimize this intermediate representation. Compilers usually translate from a high-level language like C++ or Java to a <strong>instruction set</strong> or a set of operations supported by a processor. Compilers that translate one language to another instead of from one language to a instruction set are called <strong>source-to-source translators.</strong> An <strong>interpreter</strong> is a program that takes a set of executable instructions and turns them into their output. To see the difference more clearly we can look at an example. In C++ we <em>compile</em> our programs with our favorite compilers (like gcc) and these compilers produce an output file (default to <code>a.out</code>). In python we run our program with a command like <code>pypy3 OwO.py</code> which <em>interprets</em> our input program and produces the result. Compiler designers should keep two principles in mind:</p>
<ol>
<li><p>The compiler must preserve the original meaning of the program.</p></li>
<li><p>The compiler must improve the program in some way.</p></li>
</ol>
<h2 id="compiler-structure">Compiler Structure</h2>
<p>As we said before, the front-end deals with understanding the original program and translating it into an intermediate representation(ir) and the back-end deals with turning that ir into code for the target language. Sometimes the compiler can take multiple passes over the ir to learn how it could optimize it better. These multiple passes rely on the information about the code gained by the previous passes to improve the final output. Theoretically, one ir could work as a sort of common language. We can build multiple front-ends for different languages to translate to that ir and we can create multiple back-ends that can translate from that ir to different outputs. In practice, however, specific language features and instruction set details worm their way into the ir. The kind of compilers I’ve described up to this point is called a <strong>two-phase compilers</strong>. Another kind of compiler shoves another phase into the process of compiling, an <em>optimizer.</em> The optimizer takes in an IR and outputs a (hopefully) more efficient but equivalent IR. We call these kinds of compilers a <strong>three-phase compiler.</strong> One sad truth, however, is that compilers with optimizers almost always fail to produce optimal code.</p>
<h2 id="overview-of-translation">Overview of Translation</h2>
<p>Lets first examine how we would generate executable code for <code>a=a*2*b*c*d</code></p>
<h3 id="the-front-end">The Front End</h3>
<p>The front-end’s first goal is to determine if the <strong>syntax</strong> and <strong>semantics</strong> of the input are well formed. Syntax relates to the grammar while semantics relate to the meaning. For example the sentence <em>Hide the bodies you must</em> is somewhat semantically well-formed but is obviously not syntactically correct. The famous sentence by Chomsky <em>Colorless green ideas sleep furiously</em> is syntactically correct but semantically meaningless. To check the syntax of an program we can compare it with the set of correct programs. The set of correct programs is a (usually infinite) set of strings which are defined by a finite set of rules which we call <strong>grammar.</strong> In programming languages we usually think of words based of their parts in speech. If we were to relate this to natural languages then we could break down simple sentences into a series of syntactic variables (which we’ll bold) and parts of speech (which we’ll italicize). <span class="math display">\[\textbf{sentence}\rightarrow\textbf{subject}\textit{ verb}\textbf{ object}\textit{ endmark}\]</span> For example <strong>I</strong> <em>hate</em> <strong>sand</strong><em>.</em> We can understand the right arrow as meaning <em>derives</em>. In other words, a syntactic variable of kind sentence is formed by what we have on the other side of the arrow. The task of identifying the type of each primitive belongs to the <strong>scanner.</strong> The input is a stream of characters and the output is a stream of classified words. For now we’ll think of this as a list of pairs. Lets pretend we want to run a scanner on our example sentence "I hate sand." The output of a scanner would be something along the line of<br />
<code>[("I", noun), ("hate", verb), ("sand", noun), (".", endmark)]</code><br />
Before we move on we need to define some basic grammar rules for English. For now the following will do</p>
<ol>
<li><p><span class="math inline">\(sentence\rightarrow \text{subject verb object endmark}\)</span></p></li>
<li><p><span class="math inline">\(subject\rightarrow noun\)</span></p></li>
<li><p><span class="math inline">\(object \rightarrow noun\)</span></p></li>
</ol>
<p>So we can determine the sentence "I hate sand" is syntactically correct through the following derivation <span class="math display">\[\begin{aligned}
  \textbf{sentence}\\
  \text{(by rule 1) - } \textbf{subject } \textit{verb } \textbf{object } \textit{endmark}\\
  \text{(by rule 2) - } \textit{noun } \textit{verb } \textbf{object } \textit{endmark}\\
  \text{(by rule 3) - } \textit{noun } \textit{verb } \textit{noun } \textit{endmark}\\\end{aligned}\]</span> We can see the input sentence matches the format so it’s correct. To analyze something more complex like Chomsky’s bean blaster "Colorless green ideas sleep furiously." we’d have to introduce some more rules to the grammar:</p>
<ol>
<li><p><span class="math inline">\(sentence\rightarrow \text{subject verb object endmark}\)</span></p></li>
<li><p><span class="math inline">\(sentence\rightarrow \text{subject verb endmark}\)</span></p></li>
<li><p><span class="math inline">\(sentence\rightarrow \text{subject verb adverb endmark}\)</span></p></li>
<li><p><span class="math inline">\(sentence\rightarrow \text{subject adverb verb endmark}\)</span></p></li>
<li><p><span class="math inline">\(subject\rightarrow \text{noun}\)</span></p></li>
<li><p><span class="math inline">\(subject\rightarrow \text{modifier noun}\)</span></p></li>
<li><p><span class="math inline">\(object \rightarrow \text{noun}\)</span></p></li>
<li><p><span class="math inline">\(object \rightarrow \text{modifier noun}\)</span></p></li>
<li><p><span class="math inline">\(modifier \rightarrow \text{modifier adjective}\)</span></p></li>
<li><p><span class="math inline">\(modifier \rightarrow \text{adjective}\)</span></p></li>
</ol>
<p><em>(disclaimer: I’m not sure that’s how you define modifiers for multiple adjectives but it seems to work for these purposes. The book hasn’t defined anything for multiple adjectives at this point)</em><br />
<br />
So the output of the scanner on "Colorless green ideas sleep furiously." would be<br />
<code>[("Colorless", adjective), ("green", adjective), ("ideas", noun"), ("sleep", verb), ("furiously", adverb)]</code><br />
And the derivation for the Chomsky sentence would be something like<br />
<span class="math display">\[\begin{aligned}
        \textbf{sentence}\\
        \text{(By rule 3) - } \textbf{subject } \textit{verb } \textit{adverb }\\
        \text{(By rule 6) - } \textbf{modifier } \textit{noun } \textit{verb } \textit{adverb }\\
        \text{(By rule 9) - }\textbf{modifier } \textit{adjective } \textit{noun } \textit{verb } \textit{adverb }\\
        \text{(By rule 10) - }\textit{adjective } \textit{adjective } \textit{noun } \textit{verb } \textit{adverb }\\\end{aligned}\]</span> Thus showing that the world famous Chomsky bean blaster is in fact syntactically correct. The techniques used to automatically find correct derivations is called <strong>parsing.</strong> The final task of the front-end is to generate the intermediate representation which’ll be discussed later.</p>
<h3 id="the-optimizer">The Optimizer</h3>
<p>Lets look at an example of what an optimizer might do. Given the following code</p>
<pre><code>int b = ...
int c = ...
int a = 1;
for(int i = 1; i&lt;=n; i++){
  int d;
  cin &gt;&gt; d;
  a = a*2*b*c*d;
}</code></pre>
<p>The optimizer might notice that b, c, and the value 2 remain unchanged in the loop. Therefore we could rewrite the program as</p>
<pre><code>int b = ...
int c = ...
int a = 1;
int t = 2*b*c;
for(int i = 1; i&lt;=n; i++){
  int d;
  cin &gt;&gt; d;
  a = a*t*d;
}</code></pre>
<p>This reduces the number of multiplications from 4n to 2n+2 which should execute faster. Optimization usually consists of <strong>analysis</strong> and <strong>transformation.</strong> Both of these will be discussed in future chapters.</p>
<h3 id="the-back-end">The Back End</h3>
<p>The first job of the back end is instruction selection. We go through the IR commands and determine what command to choose for them. While doing this, the compiler must also handle how values are allocated to registers. After this comes instruction scheduling which orders instructions in such a way to minimize the number of cycles taken up by the program. Most processors have the ability to start process while longer process run thus allowing for optimization. A lot of the complexity in code generation comes in the interplay between all these steps.</p>
<h1 id="scanners">Scanners</h1>
<p>The scanner reads in a stream of characters, determines if each word is valid in the context of the language and assigns each word a "part of speech".</p>
<h2 id="overview">Overview</h2>
<p>Scanners read in characters and uses a <strong>microsyntax</strong> to determine how words are formed from characters and assign syntactic categories to strings. <strong>Keywords</strong> are words that are reserved for special purposes in a language like <code>static</code> in C++. Lets say we want to built a machine to recognize the keywords <code>new</code>, <code>not</code>, and <code>while</code>. The code could be messy but the state diagram isn’t so lets take a look at that.</p>
<p><img src="nnw.png" alt="image" /></p>
<h1 id="revision-history">Revision History</h1>
<p>07-26-2019: started book<br />
07-28-2019: finished ch1, began ch 2<br />
</p>
<p><br />
<br />
<em>Think you found a mistake? You probably did. Let me know at <a href="mailto:hi@delonshen.com">hi@delonshen.com</a> if you want.</em></p>
