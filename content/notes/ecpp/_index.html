---
title: Effective C++(Meyers) Notes
---
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Delon Shen" />
  <title>notes</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#chapter-1-accustoming-yourself-to-c">Chapter 1: Accustoming Yourself to C++</a><ul>
<li><a href="#view-c-as-a-federation-of-languages.">View C++ as a federation of languages.</a></li>
<li><a href="#prefer-consts-enums-and-inlines-to-defines">Prefer consts, enums, and inlines to #defines</a></li>
<li><a href="#use-const-whenever-possible">Use const whenever possible</a></li>
<li><a href="#make-sure-that-objects-are-initialized-before-theyre-used">Make sure that objects are initialized before they’re used</a></li>
</ul></li>
<li><a href="#constructors-destructor-and-assignment-operators">Constructors, Destructor, and Assignment Operators</a><ul>
<li><a href="#know-what-functions-c-silently-writes-and-calls">Know what functions C++ silently writes and calls</a></li>
<li><a href="#explicitly-disallow-the-use-of-compiler-generated-functions-you-do-not-want.">Explicitly disallow the use of compiler-generated functions you do not want.</a></li>
<li><a href="#declare-destructor-virtual-in-polymorphic-base-classes.">Declare destructor virtual in polymorphic base classes.</a></li>
<li><a href="#prevent-exceptions-from-leaving-destructor">Prevent Exceptions from Leaving Destructor</a></li>
<li><a href="#never-call-virtual-functions-during-constructiondestruction">Never call virtual functions during construction/destruction</a></li>
<li><a href="#have-assignment-operators-return-a-reference-to-this.">Have assignment operators return a reference to *this.</a></li>
</ul></li>
<li><a href="#revision-history">Revision History</a></li>
</ul>
</nav>
<h1 id="chapter-1-accustoming-yourself-to-c">Chapter 1: Accustoming Yourself to C++</h1>
<h2 id="view-c-as-a-federation-of-languages.">View C++ as a federation of languages.</h2>
<p>Primary sub-languages of C++ are</p>
<ol>
<li><p>C</p></li>
<li><p>Object Oriented C++</p></li>
<li><p>Template C++</p></li>
<li><p>STL</p></li>
</ol>
<p><strong>tldr:</strong> effective c++ varies based on which "sub-language" you’re using</p>
<h2 id="prefer-consts-enums-and-inlines-to-defines">Prefer consts, enums, and inlines to #defines</h2>
<p>Basically, you should prefer the compiler over preprocessing. For example lets look at <code>#define PI 3.14</code>. The compiler may never see PI and put it into a symbol table and if your compiler spits out an error relating to the constant, it could refer to the actual number 3.14 instead of PI. Using define could also lead to bulkier code due to blind substitution of the macro name. Strings are preferred to char*. Class specific constants should be a member of that class (to limit scope) and be declared static (to avoid creating multiple copies.) e.g.</p>
<pre><code>  class frog{
    private:
      static const int age = 42;
      ...
  };</code></pre>
<p>In the case the above syntax isn’t allowed by the (usually old) compiler.</p>
<pre><code>class frog{
  private:
    static const int age;
    ...
};
const int frog::age = 42;</code></pre>
<p>The <strong>enum hack</strong> is useful when the compiler doesn’t allow you to declare something with a value but still need that value at compilation (like declaring size of the array.) The exploits the fact that enums can be used in lace of ints.</p>
<pre><code>class frog{
  private:
    enum{age=42};
    int bob[age];
    ...
};</code></pre>
<p>Using define to run functions is also kinda funny. Lets look at this program:</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
#define CALL_WITH_MAX(a,b) f((a)&gt;(b)?(a):(b))

int main(){
  int a = 5, b=0;
  printf(&quot;Original value of a: %d\n&quot;,a);
  CALL_WITH_MAX(++a, b);
  printf(&quot;a: %d\n&quot;,a); //a: 7
  CALL_WITH_MAX(++a, b+10);
  printf(&quot;a: %d\n&quot;,a); //a: 8
  return 0;
}</code></pre>
<p>The first time, a is incremented twice, and the second time a is incremented once. Ain’t that a stinker. Instead we should use inlines.</p>
<pre><code>template&lt;typename T&gt; inline void callWithMax(const T&amp; a, const T&amp; b) {
  f(a&gt;b?a:b);
}</code></pre>
<p><strong>tldr:</strong> use const, enums and inlines instead of #define</p>
<h2 id="use-const-whenever-possible">Use const whenever possible</h2>
<p>If const appears before an (*) then the data is const, if it appears after (*) then the pointer is const</p>
<pre><code>char greeting[]=&quot;hola&quot;;
char* p = greeting;               //non const pointer
                                  //non const data
const char *p = greeting;         //const data
char *const p = greeting;         //const pointer
const char * const p = greeting;  //const pointer
                                  //const data</code></pre>
<p>We can also use const in function declarations to avoid mistakes like <code>if(a*b=c)</code>.</p>
<pre><code>class Rational{...};
const Rational operator*(...) //makes (a*b)=c illegal</code></pre>
<p>Const member functions are useful by making us able to work with const objects. These often arise in programming when we past by reference to const. There are two kinds of const, <em>bitwise constness</em> and <em>logical constness.</em> The former thinks that a member function is const if it doesn’t modify any non-static data members. But some function that aren’t very const pass this test for constness. e.g.</p>
<pre><code>class CTextBlock {
public:
    char&amp; operator[](std::size_t position) const 
    { return pText[position]; }
};</code></pre>
<p>What we want instead is logical constnes which allows us to modify data members only in ways the client cannot tell. For this we can use the <code>mutable</code> feature of C++.</p>
<pre><code>class CTextBlock{
  public:
    std::size_t length() const;
  private:
    char* pText;
    mutable std::size_t textLength;
    mutable bool lengthIsValid;
};
std::size_t CTextBlock::length() const{
  if(!lengthIsValid){
    textLength = std::strlen(pText);
    lengthIsValid = true;
  }
  return textLength;
}</code></pre>
<p><code>const</code> and <code>non-const</code> member functions don’t have to be repeated. What we can use is const_cast!.</p>
<pre><code>class saveMe{
  public:
    ...
    const char&amp; operator[](std::size_t position){ //big const [] operator
      ... //imagine lots of code here please
      return UwU[position];
    }
    char&amp; operator[](std::size_t position){ //another [] operator but we don&#39;t want to retype or copy code
      //changes const char&amp; to char&amp; 
      //makes this object const
      //calls the const version for code saving!
      return const_cast&lt;char&amp;&gt;(static_cast&lt;const saveMe&amp;&gt;(*this)[position]);
    }
};</code></pre>
<p><strong>tldr:</strong></p>
<ol>
<li><p>Const helps compiler find usage errors</p></li>
<li><p>compilers like bitwise constness be we want logical constness</p></li>
<li><p>code duplication can be avoided by calling the const function from the non-const function</p></li>
</ol>
<h2 id="make-sure-that-objects-are-initialized-before-theyre-used">Make sure that objects are initialized before they’re used</h2>
<p>Using un-initialized variables in spooky don’t do it. Just initialize all your objects either manually or with a constructor. For example lets say we have an object pillow with a declared private variable name. In the constructor we’d want something like</p>
<pre><code>pillow::pillow(const std::string&amp; s) : name(s) {}</code></pre>
<p>Instead of</p>
<pre><code>pillow::pillow(const std::string&amp; s){
  name=s;
}</code></pre>
<p>since the latter is a assignment, not an initialization. Initialization is faster since it’s just one call to the copy constructor instead of a call to the default constructor and then an assignment. The big takeaway is always use initialization lists because they’re sometimes required and usually at least more efficient.<br />
The order that data is initialized is base classes <span class="math inline">\(\rightarrow\)</span> derived classes <span class="math inline">\(\rightarrow\)</span> data members in order of declaration. We should always just write the initializer list in the same order as the variables are declared.<br />
Now lets try to analyze this fun sentence: <em>the order of initialization of non-local static objects defined in different translation units.</em> <em>Static</em> objects are created and don’t disappear until the end of the program. Static objects inside functions are called <em>local static objects</em> and everything else is <em>non-local.</em> A <em>translation unit</em> is a source file and its #include files. Basically, we don’t want non-local static objects, we want to turn them all into local static objects to guarantee that they’re initialized. We do this through defining them static in functions. E.g.</p>
<pre><code>class FileSystem {...};
FileSystem&amp; tfs(){
  static FileSystem fs;
  return fs;
}</code></pre>
<p><strong>tldr:</strong></p>
<ol>
<li><p>Manually initialize objects</p></li>
<li><p>use initialization lists instead of assign and list members in a initialization list in the same order you declared them</p></li>
<li><p>replace non-local static objects with local static objects</p></li>
</ol>
<h1 id="constructors-destructor-and-assignment-operators">Constructors, Destructor, and Assignment Operators</h1>
<h2 id="know-what-functions-c-silently-writes-and-calls">Know what functions C++ silently writes and calls</h2>
<p>If you don’t write default constructors, copy constructors, destructor, and copy assignment, the compiler generates them for you based on what you use an object for.</p>
<pre><code>class empty{};
empty A; //default constructor and destructor generated 
empty B(A); //copy constructor generated
A=B; //copy assignment generated.</code></pre>
<p>The default constructor and destructor serve as a place for constructors and destructor of base classes and non-static members to be put. The destructor is virtual only if the class derives from another class with a virtual destructor. Copy constructor/assignment copy non-static members from the source to the target object. If a constructor exists, then the compiler won’t generated a default constructor.<br />
<strong>tldr:</strong> the compiler might implicitly generate default constructors, copy constructors, destructor, and copy assignments.</p>
<h2 id="explicitly-disallow-the-use-of-compiler-generated-functions-you-do-not-want.">Explicitly disallow the use of compiler-generated functions you do not want.</h2>
<p>Don’t want the pesky compiler to generate a copy-assignment/constructor for you but also don’t want these functions to work? Then <span class="underline">declare and make private</span> the functions you don’t want to be unusable and don’t want the compiler to generate. This would generate a link-time/run-time error when people try to use the copy constructor and assignment. But we can do better! Lets make a class that’ll let these errors be detected at compile time.</p>
<pre><code>class Uncopyable{
  protected:
    Uncopyable() {}
    ~Uncopyable() {}
  private:
    Uncopyable(const Uncopyable&amp;)
    Uncopyable&amp; operator=(const Uncopyable^);
};</code></pre>
<p>And when we have a class that we don’t want a copy assignment/constructor for. we just inherit stuff from uncopyable.</p>
<pre><code>class Pillows:private Uncopyable{
  ...
};</code></pre>
<p><strong>tldr:</strong> To disallow functions that the compiler generates. Declare/make private these functions. A base class like Uncopyable works too.</p>
<h2 id="declare-destructor-virtual-in-polymorphic-base-classes.">Declare destructor virtual in polymorphic base classes.</h2>
<p>Lets say you want to get the time and you define a class TimeKeeper in which multiple methods of getting the time is derived from. Now a user wants to know the time but doesn’t really care about the method for getting the time so you define a function TimeKeeper* getTimeKeeper() that allows a pointer to any class derived from TimeKeeper. When you call the destructor on the pointer, the object is only partially destroyed since we call TimeKeeper’s destructor instead of the class’s specific destructor (e.g. AtomicClock’s destructor). To avoid this we should declare TimeKeeper’s destructor to be virtual so the destructor works as intended and we don’t get funky partially deleted objects. You don’t want to declare destructor virtual all the time though, for classes that aren’t meant to be base classes, declaring a destructor increases the size of that object. This is because there is some extra overhead associated with using virtual functions. Deriving a class from a class with non-virtual destructor(like most stl containers) can be dangerous too. For example the following code is in undefined behavior territory.</p>
<pre><code>class SpecialString: public std::string{....};
SpecialString *pss = new SpecialString(&quot;I&#39;m a big idiot&quot;);
std::string *ps;
ps = pss;
delete ps; </code></pre>
<p>If you have a class you want to be abstract but don’t have any pure-virtual functions, declare the destructor as pure virtual</p>
<pre><code>class lmao{
  public:
   virtual ~lmao() = 0;
};
lmao::~lmao(){} //define it since ~lmao will be called from derived classes.</code></pre>
<p><strong>tldr:</strong></p>
<ol>
<li><p>Polymorphic base classes / class with any virtual functions should have a virtual destructor</p></li>
<li><p>Classes not designed to be base classes or be used polymorphically should not have virtual destructor.</p></li>
</ol>
<h2 id="prevent-exceptions-from-leaving-destructor">Prevent Exceptions from Leaving Destructor</h2>
<p>Destructor throwing exception is bad since it can lead to undefined behavior or just premature termination. There are two unappealing ways to deal with this in the destructor which is by ending the program with std::abort() or just eat the exception and keep chugging. One way to deal with exceptions to create a non-destructor function does some operations the destructor would do and leave it to the client to call this "close" function so that they have a chance to react to the exception instead of the destructor just flailing.</p>
<h2 id="never-call-virtual-functions-during-constructiondestruction">Never call virtual functions during construction/destruction</h2>
<p>When calling the constructor of a derived class, the base class is constructed first and all of C++ treats that object as the base class until the derived class construction begins. This is because the local members of the derived class aren’t even initialized yet so for all intents and purposes they don’t exist. Destructors are similar. Once the derived classes destructor is called, it’s treated as if it’s the base class while the base class destructor is called. Because of this, virtual functions won’t work as you think they will in constructors/destructors.<br />
<strong>tldr:</strong> this one’s short as heck.</p>
<h2 id="have-assignment-operators-return-a-reference-to-this.">Have assignment operators return a reference to *this.</h2>
<p>This is just convention for all the built-in-types and stl. e.g.</p>
<pre><code>class Widget{
  public:
    Widget&amp; operator+=(const Widget&amp; rhs){
      ...
      return *this;
    }
    Widget&amp; oeratpr=(int rhs){
      ...
      return *this;
    }
};</code></pre>
<p><strong>tldr:</strong> it’s one sentence.</p>
<h1 id="revision-history">Revision History</h1>
<p>07-18-2019: began book<br />
07-19-2019: finished item 3 and 4<br />
07-22-2019: finished items 5-10<br />
</p>
<p><br />
<br />
<em>Think you found a mistake? You probably did. Let me know at <a href="mailto:hi@delonshen.com">hi@delonshen.com</a> if you want.</em></p>
</body>
</html>
