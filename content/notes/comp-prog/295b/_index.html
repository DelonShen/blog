---
title: Codeforces Round 295 (Div. 2) B - Two Buttons
---
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Delon Shen" />
  <title>295b.tex</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<p><a href="http://codeforces.com/problemset/problem/520/B">Link to problem</a><br />
<strong>Solution</strong><br />
For this problem what we can do is create a graph of 2*(max(n,m))+10 nodes. The plus 10 is because Iâ€™m insecure about my ability to set the proper boundaries in my program. Each node, i, has a directed edge going from it to the node i-1 and 2*i. With this graph we can do a BFS starting at n to find m. Since this is a unweighted graph, the BFS will find the shortest path to m which will give us our solution.<br />
<strong>Code</strong></p>
<pre><code>#include &lt;bits/stdc++.h&gt;
typedef int OwO; typedef double UwU;
#define int long long
#define double long double

using namespace std;
OwO main(){
  ios::sync_with_stdio(false);
  cin.tie(NULL);
  int n,m;
  cin &gt;&gt; n &gt;&gt; m;
  vector&lt;vector&lt;int&gt;&gt; graph(2*max(n,m)+10, vector&lt;int&gt;());
  for(int x = 1; x&lt;=2*max(n,m)+5; x++){
    graph[x].push_back(x-1);
    if(2*x&lt;2*max(n,m)+10)
      graph[x].push_back(2*x);
  }
  vector&lt;int&gt; dist(2*max(n,m)+10, 11234567);
  vector&lt;int&gt; visited(2*max(n,m)+10, 0);
  queue&lt;int&gt; q;
  q.push(n);
  dist[n] = 0;
  while(q.size()){
    int curr = q.front();
    q.pop();
    if(visited[curr])
      continue;
    visited[curr]=1;
    if(curr==m){
      cout &lt;&lt; dist[curr] &lt;&lt; endl;
      return 0;
    }
    for(auto e:graph[curr]){
      q.push(e);
      dist[e] = min(dist[e], dist[curr]+1);
    }
  }

  return 0;
}</code></pre>
<p><em>Think you found a mistake? You probably did. Let me know at <a href="mailto:hi@delonshen.com">hi@delonshen.com</a> if you want.</em></p>
</body>
</html>
