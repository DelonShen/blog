---
title: AtCoder Beginner Contest 128 D - enqueue
---
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Delon Shen" />
  <title>abc128d.tex</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<p><a href="https://atcoder.jp/contests/abc128/tasks/abc128_d&lt;Paste&gt;">Link to problem</a><br />
<strong>Solution</strong><br />
What we can do is use a nested for loop to try all possible cases. The outer loop will keep track of how many we’ll take from the left(tl) of the deque and the inner loop will keep track of how many we will take from the right(tr) of the deque. Inside the inner loop we’ll generate the hand given by taking tl from the front of the deque and tr from the right of the deque. From there we’ll simulate putting items from our hand back back into the deque by by removing the M smallest elements where M is the min(num_negative_elements, K-(tl+tr)). We do this ensure that we get rid of as many negative elements as possible (in the case where there are more negative elements than we have moves left) or all the negative elements(in which case we’ll end up with leftover moves.) Once that’s done, we sum up the elements in our hand and properly update the output value. Once the nested for loop is done running, we should have our answer. I’m not gonna analyze the complexity of this solution but it’s something like <span class="math display">\[50\cdot 50 \cdot (100 + 100lg(100) +100)\]</span> which is a lot smaller than <span class="math inline">\(10^9\)</span>.<br />
<strong>Code</strong></p>
<pre><code>#include &lt;bits/stdc++.h&gt;
#include &lt;ext/pb_ds/assoc_container.hpp&gt; //__gnu_pbds::gp_hash_table&lt;int, int&gt; table;
//priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pq;  //min heap

typedef int OwO;
typedef double UwU;

#define int long long
#define double long double
#define INF 1000000000
#define PI 3.14159265358979323846
#define watch(x) cout &lt;&lt; (#x) &lt;&lt; &quot; is &quot; &lt;&lt; (x) &lt;&lt; endl
#define pii pair&lt;int, int&gt;
#define vpii vector&lt;pair&lt;int, int&gt;&gt;
#define vvi vector&lt;vector&lt;int&gt;&gt;
#define vi vector&lt;int&gt;

using namespace std;



OwO main(){
  ios::sync_with_stdio(false);
  cin.tie(NULL);
  int N, K;
  cin &gt;&gt; N &gt;&gt; K;
  vector&lt;int&gt; t;
  for(int x = 0; x&lt;N; x++){
    int a;
    cin &gt;&gt; a;
    t.push_back(a);
  }
  int oup = -INF;
  for(int tl = 0; tl&lt;=min(N,K); tl++){
    for(int tr = 0; tr+tl&lt;min(N, K)+1; tr++){
      int size = tl+tr;
      vi hand = t;
      hand.erase(hand.begin()+tl, hand.end()-tr);
      sort(hand.rbegin(), hand.rend());
      for(int x = 0; hand.size() &amp;&amp; x&lt;K-size &amp;&amp; hand[size-x-1]&lt;0; x++)
        hand.pop_back();
      oup = max(oup, (int)accumulate(hand.begin(), hand.end(), 0));
    }
  }
  cout &lt;&lt; oup &lt;&lt; endl;
  return 0;
}</code></pre>
<p><em>Think you found a mistake? You probably did. Let me know at <a href="mailto:hi@delonshen.com">hi@delonshen.com</a> if you want.</em></p>
</body>
</html>
