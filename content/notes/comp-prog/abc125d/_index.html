---
title: AtCoder Beginner Contest 125 D - Flipping Signs
---
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Delon Shen" />
  <title>abc125d.tex</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<p><a href="https://atcoder.jp/contests/abc125/tasks/abc125_d">Link to problem</a><br />
<strong>Solution</strong><br />
We should notice that</p>
<ol>
<li><p>If there are an even number of negative numbers then it is always possible to flip all of them</p></li>
<li><p>If there an odd number of negative numbers, we can either flip all of them and one positive number or flip all but one negative number.</p></li>
</ol>
<p>To see this, we can consider a set of 3 numbers. There are eight possibilities for these numbers if we only care if they’re positive or negative. <span class="math display">\[\begin{aligned}
  &amp;NNN\\
  &amp;NNP\\
  &amp;NPN\\
  &amp;NPP\\
  &amp;PNN\\
  &amp;PNP\\
  &amp;PPN\\
  &amp;PPP\end{aligned}\]</span> Every case has the property that we previously talked about. There’s probably a neat inductive proof that’ll prove this for all possible sequences but this was enough for me. So our output would simply depend on the number of negative numbers. If there are a even number of negative numbers then we simply return the sum of the array if every element was positive. If there’s an odd number of negative numbers then we return the maximum between (sum of array if all numbers are positive except for the smallest positive number before flipping) and (sum of array if all numbers are positive except for the negative numbers with the smallest absolute value.)<br />
<strong>Code</strong></p>
<pre><code>#include &lt;bits/stdc++.h&gt;
#include &lt;ext/pb_ds/assoc_container.hpp&gt; //__gnu_pbds::gp_hash_table&lt;int, int&gt; table;
//priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pq;  //min heap

typedef int OwO;
typedef double UwU;

#define int long long
#define double long double
#define INF 1000000000
#define PI 3.14159265358979323846
#define watch(x) cout &lt;&lt; (#x) &lt;&lt; &quot; is &quot; &lt;&lt; (x) &lt;&lt; endl
#define pii pair&lt;int, int&gt;
#define vpii vector&lt;pair&lt;int, int&gt;&gt;
#define vvi vector&lt;vector&lt;int&gt;&gt;
#define vi vector&lt;int&gt;

using namespace std;

OwO main(){
  ios::sync_with_stdio(false);
  cin.tie(NULL);
  int N;
  cin &gt;&gt; N;
  vi t(N);
  int c_n = 0;
  int abs_sum = 0;
  int m_p = INF;
  int m_n = -INF;
  for(int x=0; x&lt;N; x++){
    cin &gt;&gt; t[x];
    if(t[x]&lt;=0){
      c_n++;
      m_n=max(m_n, t[x]);
    }
    abs_sum+=abs(t[x]);
    if(t[x]&gt;0)
      m_p = min(m_p, t[x]);
  }
  if(c_n%2==0)
    cout &lt;&lt; abs_sum &lt;&lt; endl;
  else{
    cout &lt;&lt; max(abs_sum-2*m_p, abs_sum+2*m_n) &lt;&lt; endl;
  }

  return 0;
}</code></pre>
<p><em>Think you found a mistake? You probably did. Let me know at <a href="mailto:hi@delonshen.com">hi@delonshen.com</a> if you want.</em></p>
</body>
</html>
